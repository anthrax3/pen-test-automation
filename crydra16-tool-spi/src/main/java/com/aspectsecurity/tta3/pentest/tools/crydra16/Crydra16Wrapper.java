package com.aspectsecurity.tta3.pentest.tools.crydra16;

import com.aspectsecurity.astam.tta3.pentest.common.ExecutionResult;
import com.aspectsecurity.astam.tta3.pentest.common.ToolCommand;
import com.aspectsecurity.astam.tta3.pentest.common.ToolResult;
import com.aspectsecurity.astam.tta3.pentest.common.Tta3Attack;
import com.aspectsecurity.astam.tta3.pentest.tools.spi.ToolParameter;
import com.aspectsecurity.astam.tta3.pentest.tools.spi.ToolWrapper;
import com.aspectsecurity.astam.tta3.pentest.tools.spi.common.StringToolParameter;
import com.aspectsecurity.astam.tta3.pentest.tools.spi.common.IntegerToolParameter;
import com.google.common.collect.ImmutableSet;
import org.apache.commons.lang3.builder.ToStringBuilder;
import com.google.gson.Gson;

import java.util.*;

/*
    Application Security Threat Attack Modeling (ASTAM)

    Copyright (C) 2017 Applied Visions - http://securedecisions.com

    Written by Aspect Security - https://aspectsecurity.com

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
 * Wrapper SPI for Crydra-16 tool.
 *
 * @author Aspect Security
 */
public class Crydra16Wrapper implements ToolWrapper {

    private static final Set<String> SUPPORTED_ATTACKS = ImmutableSet.of("CAPEC-16");

    final StringToolParameter usernameParameter = new StringToolParameter("username",
            // TODO: support internationalization with parameterized message string
            "Target Account's Username",
            true);

    final StringToolParameter hostParameter = new StringToolParameter("host",
            // TODO: support internationalization with parameterized message string
            "Target Machine to test",
            true);

    final IntegerToolParameter portParameter = new IntegerToolParameter("port",
            // TODO: support internationalization with parameterized message string
            "Target Machine's HTTP or HTTPS port",
            true);

    final StringToolParameter useTLSParameter = new StringToolParameter("useTLS",
            // TODO: support internationalization with parameterized message string
            "Use TLS on the port above, 0=no, anything else=yes",
            true);

    final StringToolParameter uripathParameter = new StringToolParameter("uripath",
            // TODO: support internationalization with parameterized message string
            "PATH to use",
            true);

    final StringToolParameter formdataParameter = new StringToolParameter("formdata",
            // TODO: support internationalization with parameterized message string
            "POST or GET form data, see the documentation for injection points",
            true);
    final StringToolParameter msgsuccessParameter = new StringToolParameter("msgsuccess",
            // TODO: support internationalization with parameterized message string
            "Success message if login worked, this is a regex",
            true);
    final StringToolParameter dictionaryfileParameter = new StringToolParameter("dictionaryfile",
            // TODO: support internationalization with parameterized message string
            "Dictionary file used for passwords",
            true);

    final Set<ToolParameter> toolParameters = ImmutableSet.of(
            usernameParameter,
            hostParameter,
            portParameter,
            useTLSParameter,
            uripathParameter,
            formdataParameter,
            msgsuccessParameter,
            dictionaryfileParameter

    );

    @Override
    public String getToolName() {
        return "crydra-16";
    }

    @Override
    public Set<ToolParameter> getToolParameters() {
        return toolParameters;
    }

    @Override
    public Set<String> getSupportedAttacks() {
        return SUPPORTED_ATTACKS;
    }


    // This is the Java-class version of Hydra's Json output.  Not all fields are necessarily used in this project.

    private static class HydraOutput {
        public static class SoftwareGenerator {
            public String software;
            public String version;
            public String built;
            public String server;
            public String service;
            public String jsonoutputversion;
            public String commandline;
        }

        private static class OneResult {
            public int port;
            public String service;
            public String host;
            public String login;
            public String password;
        }


        public SoftwareGenerator generator;
        Collection<OneResult> results;
        Collection<String> errormessages;
        public boolean success;
        public int quantityfound;
    }


    @Override
    public ToolResult parseAttackResult(Tta3Attack attack, ExecutionResult executionResult) {

//        ExecutionResult res = executionResult;

        // Hydra with -b flag outputs Json, so parse that.
        Gson gson = new Gson();

        // TODO If the Json is not valid, then hydra had a serious issue running, need to capture Exception.
        HydraOutput hydraOutput = gson.fromJson(executionResult.getResultFileContents(), HydraOutput.class);

        if (hydraOutput == null) {
            return new ToolResult(false, false, 0, "Error parsing JSON");
        }

        if (!"1.00".equals(hydraOutput.generator.jsonoutputversion)) {
            // TODO: Internationalization
            throw new UnknownFormatConversionException("Unknown Hydra JSON Version");
        }

        if (hydraOutput.success == false) {
            // TODO: Internationalization
            return new ToolResult(false, false, 0, "There was a problem running the tool");
        }

        // collect the passwords

        List<Crydra16Results.DiscoveredPassword> discoveredPasswords = new ArrayList<>();
        StringBuilder resultsText = new StringBuilder();

        for (HydraOutput.OneResult one : hydraOutput.results) {

            StringBuilder sb = new StringBuilder();
            Crydra16Results.DiscoveredPassword discoveredPassword = new Crydra16Results.DiscoveredPassword(one.login, one.password);

            discoveredPasswords.add(discoveredPassword);


            resultsText.append("Username: ");
            resultsText.append(one.login);
            resultsText.append(" / Password: ");
            resultsText.append(one.password);
            resultsText.append("\n");

            resultsText.append(sb.toString());
        }


        return new Crydra16Results(true, !discoveredPasswords.isEmpty(), discoveredPasswords.size(),
                resultsText.toString(), discoveredPasswords);
    }

    @Override
    public ToolCommand generateToolCommand(Tta3Attack attack) {
        if (!getSupportedAttacks().contains(attack.getCapecId())) {
            // TODO: support internationalization with parameterized message string
            throw new UnsupportedOperationException("Attack " + attack.getCapecId() + " is not supported.");
        }

        if (!isValidParameters()) {
            // TODO: support internationalization with parameterized message string
            throw new IllegalArgumentException("Invalid attack configuration.");
        }

        return new ToolCommand(getToolName(), generateCrydra16ConfFile().getBytes(),true);
    }

    private boolean isValidParameters() {
        return toolParameters.parallelStream().allMatch(t -> (
                // if the value is not null, it must be valid
                (t.getValue() != null && t.isValid())
                        // if the value is null, then it must be not required
                      || (t.getValue() == null && !t.isRequired())
        ));
    }

    private String generateCrydra16ConfFile() {
        StringBuilder fileContents = new StringBuilder("## Generated Crydra-16 attack configuration file\n");

        toolParameters.forEach(t -> fileContents.append(t.generateShellConfigLine() ));

        fileContents.append("## Common defaults that are not in the GUI just yet...\n");
        fileContents.append("threads=2\n");

        return fileContents.toString();
    }

    @Override
    public String toString() {
        return new ToStringBuilder(this).
                append("toolName", getToolName()).
                append("supportedAttacks", getSupportedAttacks()).
                toString();
    }


    // TODO: Convert this into a Unit Test
//    public static void main(String[] args) throws Exception {
//        Crydra16Wrapper thisClass = new Crydra16Wrapper();
//        String filename;
//
//        /*
//        if (args.length != 1) {
//            System.out.println("This is a convenience commandline function parses a results file from disk and displays tool results");
//            System.out.println("java classname <file to parse>");
//            System.exit(0);
//        }
//
//        filename = args[0];
//        */
//
//        filename = "/Users/jball/proj/ASTAM/hydra-sample-results.txt";
//
//        ExecutionResult tr = new ExecutionResult("", filename);
//        ExecutionResult parsed = thisClass.parseAttackResult(null,tr);
//
//        System.out.print(parsed.toString());
//    }
}

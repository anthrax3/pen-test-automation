package com.aspectsecurity.tta3.pentest.tools.esm7;

import com.aspectsecurity.astam.tta3.pentest.common.ExecutionResult;
import com.aspectsecurity.astam.tta3.pentest.common.ToolCommand;
import com.aspectsecurity.astam.tta3.pentest.common.ToolResult;
import com.aspectsecurity.astam.tta3.pentest.common.Tta3Attack;
import com.aspectsecurity.astam.tta3.pentest.tools.spi.ToolParameter;
import com.aspectsecurity.astam.tta3.pentest.tools.spi.ToolWrapper;
import com.aspectsecurity.astam.tta3.pentest.tools.spi.common.StringToolParameter;
import com.aspectsecurity.astam.tta3.pentest.tools.spi.common.UrlToolParameter;
import com.aspectsecurity.tta3.pentest.tools.esm7.domain.SQLMapInjectionPoint;
import com.aspectsecurity.tta3.pentest.tools.esm7.domain.SQLMapResultSet;
import com.aspectsecurity.tta3.pentest.tools.esm7.domain.SQLMapResults;
import com.google.common.collect.ImmutableSet;
import org.apache.commons.lang3.builder.ToStringBuilder;
import com.google.gson.Gson;
import com.google.gson.JsonParser;
import com.google.gson.JsonElement;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import org.apache.commons.lang3.builder.ToStringStyle;

import java.util.*;

/*
    Application Security Threat Attack Modeling (ASTAM)

    Copyright (C) 2017 Applied Visions - http://securedecisions.com

    Written by Aspect Security - http://aspectsecurity.com

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
 * Wrapper SPI for ESM-7 tool.
 *
 * @author Aspect Security
 */
public class Esm7Wrapper implements ToolWrapper {

    public enum SqlMapContentType {
        TARGET(0),
        TECHNIQUES(1),
        DBMS_FINGERPRINT(2),
        BANNER(3),
        CURRENT_USER(4),
        CURRENT_DB(5),
        HOSTNAME(6),
        IS_DBA(7),
        USERS(8),
        PASSWORDS(9),
        PRIVILEGES(10),
        ROLES(11),
        DBS(12),
        TABLES(13),
        COLUMNS(14),
        SCHEMA(15),
        COUNT(16),
        DUMP_TABLE(17),
        SEARCH(18),
        SQL_QUERY(19),
        COMMON_TABLES(20),
        COMMON_COLUMNS(21),
        FILE_READ(22),
        FILE_WRITE(23),
        OS_CMD(24),
        REG_READ(25);

        public final int code;

        SqlMapContentType(int code) {
            this.code = code;
        }
    }

    private static final Set<String> SUPPORTED_ATTACKS = ImmutableSet.of("CAPEC-7", "CAPEC-66");

    final UrlToolParameter loginUrlParameter = new UrlToolParameter("loginURL",
            // TODO: support internationalization with parameterized message string
            "URL for authentication and/or session cookie",
            false);

    // TODO: convert this to an http request tool parameter
    final StringToolParameter loginPostParameter = new StringToolParameter("loginPOST",
            // TODO: support internationalization with parameterized message string
            "HTTP POST parameter string for authentication",
            false);

    final UrlToolParameter sqliUrlParameter = new UrlToolParameter("sqliURL",
            // TODO: support internationalization with parameterized message string
            "URL for attack location",
            true);

    // TODO: convert this to an http request tool parameter
    final StringToolParameter sqliPostParameter = new StringToolParameter("sqliPOST",
            // TODO: support internationalization with parameterized message string
            "HTTP POST parameter string for attack location",
            false);

    final StringToolParameter sqliParamParameter = new StringToolParameter("sqliParam",
            // TODO: support internationalization with parameterized message string
            "Parameter to test",
            false);

    final Set<ToolParameter> toolParameters = ImmutableSet.of(
            loginUrlParameter,
            loginPostParameter,
            sqliUrlParameter,
            sqliPostParameter,
            sqliParamParameter
    );

    @Override
    public String getToolName() {
        return "esm-7";
    }

    @Override
    public Set<ToolParameter> getToolParameters() {
        return toolParameters;
    }

    @Override
    public Set<String> getSupportedAttacks() {
        return SUPPORTED_ATTACKS;
    }

    /* The SQLmap output that we consume is either the "ASTAM combined all data format" as generated by our command line
     * tool or the raw native SQLmap format. As such, we need to load the full JSON into memory and walk it to figure
     * this out.
     */

    private class SQLMapData {
        public int status;
        public int type;
        public JsonElement value;


        public String toString() {
            return ToStringBuilder.reflectionToString(this, ToStringStyle.SIMPLE_STYLE);
        }
    }

    @Override
    public ToolResult parseAttackResult(Tta3Attack attack, ExecutionResult executionResult)
    {
        Gson gson = new Gson();
        ArrayList<SQLMapData> dataJsonObjects = new ArrayList<>();

        JsonElement rootJsonElement = new JsonParser().parse(executionResult.getResultFileContents());

        // Returns Root element (which is a JsonElement, can be object, array, null or primitive)
        if (rootJsonElement.isJsonObject())
        {
            JsonObject rootJsonObject = rootJsonElement.getAsJsonObject();

            if (rootJsonObject.has("data_response"))
            {
                // Then we are using the ASTAM data import
                JsonObject dataResponseObject = rootJsonObject.getAsJsonObject("data_response");

                JsonArray dataResponseDataArray = dataResponseObject.getAsJsonArray("data");
                dataResponseDataArray.forEach( data -> dataJsonObjects.add(0, gson.fromJson(data ,SQLMapData.class)));
            }
            else
            {
                // CONDITION: ???
                // If we get here, we have a condition that hasn't been handled in this function yet,
                // but we do know with some certainty that there is no result data

                // FIXME: this should never happen because ESM-7 handles running status
                throw new UnknownFormatConversionException("Unknown JSON format");
            }
        }
        else
        {
            throw new IllegalArgumentException("partialResults.resultFileData is not a valid JSON object.");
        }

        // TODO below we need to figure out what data is needed for down stream systems - for now, just ignore this

        // If we get to this point, awesome, some type of SQL injection data was present. Now we'll parse it

//        SQLMapResultSet theResultSet = new SQLMapResultSet();
//        theResultSet.resultSet = new ArrayList<>();

//        int paramCount = 0;
//        int injectionPointCount = 0;


        // If there is a vulnerability, there should be 3 entries (based on original ESM-7 design)
        if ( dataJsonObjects.size() == 3 ) {

            String target = "Unknown";
            String banner = "Unknown";
            int paramCount = 0;
            Collection<Esm7Results.DiscoveredInjection> injectionPoints = new ArrayList<>();

            for (SQLMapData dataJsonObject : dataJsonObjects)
            {
                if (SqlMapContentType.TARGET.code == dataJsonObject.type) {
                    JsonObject valueJsonObject = dataJsonObject.value.getAsJsonObject();

                    StringBuilder targetStringBuilder = new StringBuilder();
                    targetStringBuilder.append(valueJsonObject.getAsJsonPrimitive("url").getAsString());

                    String query = valueJsonObject.getAsJsonPrimitive("query").getAsString();

                    if (query != null) {
                        targetStringBuilder.append('?');
                        targetStringBuilder.append(query);
                    }

                    target = targetStringBuilder.toString();
                } else if (SqlMapContentType.TECHNIQUES.code == dataJsonObject.type)
                {
                    // "value" field contains an array of data elements - each has {payload, title, vector, location}
                    JsonArray dataJsonArray = dataJsonObject.value.getAsJsonArray();
                    for (JsonElement valueElement : dataJsonArray)
                    {
                        JsonObject valueObject = valueElement.getAsJsonObject();

                        String parameter = valueObject.get("parameter").getAsString();;
                        String dbms = valueObject.get("dbms").getAsString();;


                        // Now handle the "data" field, iterating through to get a list of injection points...
                        JsonObject dataField = valueObject.getAsJsonObject("data");
                        Iterator<Map.Entry<String, JsonElement>> injectionDataIterator = dataField.entrySet().iterator();

                        while (injectionDataIterator.hasNext())
                        {
                            Map.Entry<String, JsonElement> thisDataEntry = injectionDataIterator.next();

                            JsonObject injectionDataContents = thisDataEntry.getValue().getAsJsonObject();


                            String payload = injectionDataContents.get("payload").getAsString();
                            String vector = injectionDataContents.get("vector").getAsString();

                            injectionPoints.add(new Esm7Results.DiscoveredInjection(parameter, dbms, payload, vector));
                        }

                        paramCount++;
                    }
                } else if (SqlMapContentType.BANNER.code == dataJsonObject.type) {
                    banner = dataJsonObject.value.getAsString();
                }
            }

            StringBuilder resultsText = new StringBuilder("Discovered a total of ");

            resultsText.append(paramCount);
            resultsText.append(" parameter + DBMS sets. An overall ");
            resultsText.append(injectionPoints.size());
            resultsText.append(" injection points were identified:\n");

            for (Esm7Results.DiscoveredInjection injection : injectionPoints) {
                resultsText.append("\t * ");
                resultsText.append(injection.getVector());
                resultsText.append('\n');
            }

            return new Esm7Results(true, true,
                    1,  resultsText.toString(), target, banner,
                    injectionPoints);
        } else if ( dataJsonObjects.size() == 0 ) {
            return new ToolResult(true, false, 0,
                    "No SQL injection vulnerabilities found.");
        } else {
            // this should never happen unless we change the behavior of ESM-7 (in which case an exception
            //   will help us realize this code needs to change!

            throw new UnknownFormatConversionException(this.getClass().getSimpleName() + " expected 3 data elements.");
        }
    }

    @Override
    public ToolCommand generateToolCommand(Tta3Attack attack) {
        if (!getSupportedAttacks().contains(attack.getCapecId())) {
            // TODO: support internationalization with parameterized message string
            throw new UnsupportedOperationException("Attack " + attack.getCapecId() + " is not supported.");
        }

        if (!isValidParameters()) {
            // TODO: support internationalization with parameterized message string
            throw new IllegalArgumentException("Invalid attack configuration.");
        }

        return new ToolCommand("esm-7", generateEsm7ConfFile().getBytes(),true);
    }

    private boolean isValidParameters() {
        return toolParameters.parallelStream().allMatch(t -> (
                // if the value is not null, it must be valid
                (t.getValue() != null && t.isValid())
                        // if the value is null, then it must be not required
                      || (t.getValue() == null && !t.isRequired())
        ));
    }

    private String generateEsm7ConfFile() {
        StringBuilder fileContents = new StringBuilder("## Generated ESM-7 attack configuration file\n");


        // URL for authentication and/or session cookie (optional)
        if (loginUrlParameter.getValue() != null) {
            fileContents.append("loginURL='").append(loginUrlParameter.getValue()).append("'\n");
        }

        // HTTP POST parameter string for authentication (optional)
        if (loginPostParameter.getValue() != null) {
            fileContents.append("loginPOST='").append(loginPostParameter.getValue()).append("'\n");
        }

        // URL for attack location (required)
        fileContents.append("sqliURL='").append(sqliUrlParameter.getValue()).append("'\n");

        // HTTP POST parameter string for attack location (optional)
        if (sqliPostParameter.getValue() != null) {
            fileContents.append("sqliPOST='").append(sqliPostParameter.getValue()).append("'\n");
        }

        // Parameter to test (optional)
        if (sqliParamParameter.getValue() != null) {
            fileContents.append("sqliParam='").append(sqliParamParameter.getValue()).append("'\n");
        }

        return fileContents.toString();
    }

    @Override
    public String toString() {
        return new ToStringBuilder(this).
                append("toolName", getToolName()).
                append("supportedAttacks", getSupportedAttacks()).
                toString();
    }

    // TODO: Convert to a Unit Test
//    public static void main(String[] args) throws Exception
//    {
//        Esm7Wrapper thisClass = new Esm7Wrapper();
//
//        if (args.length != 1)
//        {
//            System.out.println("This is a convenience command line function.");
//            System.out.println("It parses a results file from disk and displays tool results." + "\n");
//
//            System.out.println("java classname <file to parse>");
//
//            System.exit(0);
//        }
//
//        String filename = args[0];
//
//        ExecutionResult tr = new ExecutionResult("", filename);
//        ExecutionResult parsed = thisClass.parseAttackResult(null, tr);
//
//        System.out.print(parsed.toString());
//    }
}

package com.aspectsecurity.astam.tta3.pentest.execute.cli;

/*
    Application Security Threat Attack Modeling (ASTAM)

    Copyright (C) 2017 Applied Visions - http://securedecisions.com

    Written by Aspect Security - http://aspectsecurity.com

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

import com.aspectsecurity.astam.tta3.pentest.common.ExecutionResult;
import com.aspectsecurity.astam.tta3.pentest.common.ToolCommand;
import com.aspectsecurity.astam.tta3.pentest.common.Tta3Attack;
import com.aspectsecurity.astam.tta3.pentest.execute.CommandExecutor;
import com.aspectsecurity.astam.tta3.pentest.execute.ExecutionId;
import org.apache.commons.exec.*;
import org.apache.commons.exec.environment.EnvironmentUtils;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.*;

/**
 *
 */
public class CliExecutor implements CommandExecutor {

    private Map<ExecutionId, Boolean> executionStatuses = new HashMap<>();
    private Map<ExecutionId, ExecutionResult> executionResults = new HashMap<>();

    private boolean debug;

    public CliExecutor() {
        this(false);
    }

    public CliExecutor(boolean debug) {
        this.debug = debug;
    }

    @Override
    public ExecutionId execute(Tta3Attack attack, ToolCommand command) {

        DefaultExecutor executor = new DefaultExecutor();
        executor.getWorkingDirectory();

        byte[] bytes = command.getFileContents();
        final File tempFile;
        final File resultsFile;
        try {
            tempFile = File.createTempFile("attack-", ".conf");
            tempFile.deleteOnExit();
            resultsFile = File.createTempFile("results-",".txt");
            resultsFile.deleteOnExit();

            try (FileOutputStream fileOutputStream = new FileOutputStream(tempFile)) {
                fileOutputStream.write(bytes);
                fileOutputStream.close();
            }

            ByteArrayOutputStream executorOutputStream = new ByteArrayOutputStream();
            ByteArrayOutputStream executorErrorStream = new ByteArrayOutputStream();
            executor.setStreamHandler(new PumpStreamHandler(executorOutputStream, executorErrorStream));
//            executor.setStreamHandler(new PumpStreamHandler(System.out, System.err));

            CommandLine commandLine = new CommandLine(command.getToolExecutableName());
            if (command.isVerbose()) {
                commandLine.addArgument("-v");
            }

            Map<String, File> commandLineMap = new HashMap<String, File>();
            commandLineMap.put("attackfile", tempFile);
            commandLineMap.put("resultsFile", resultsFile);

            commandLine.setSubstitutionMap(commandLineMap);
            commandLine.addArgument("${attackfile}");
            commandLine.addArgument("${resultsFile}");

            ExecutionId id = new ExecutionId();
            executionStatuses.put(id, false);
            executionResults.put(id, null);
            DefaultExecuteResultHandler handler;


            if (!debug) {
                executor.execute(commandLine, EnvironmentUtils.getProcEnvironment(), new ExecuteResultHandler() {

                    @Override
                    public void onProcessComplete(int exitValue) {

                        String resultsFileContents;
                        try {
                            byte[] encoded = Files.readAllBytes(resultsFile.toPath());
                            resultsFileContents = new String(encoded, StandardCharsets.UTF_8);
                        } catch (IOException ioe) {
                            resultsFileContents = ioe.toString();
                        }

                        ExecutionResult executionResult = new ExecutionResult(executorOutputStream.toString(), executorErrorStream.toString(),
                                exitValue, resultsFileContents);

                        // for concurrency reasons, result must be placed into map before status is
                        // (to avoid situation where result is not yet in map and a thread detects the status is updated)
                        executionResults.put(id, executionResult);
                        executionStatuses.put(id, true);
                    }

                    @Override
                    public void onProcessFailed(ExecuteException e) {
                        String resultsFileContents = e.toString();

                        ExecutionResult executionResult = new ExecutionResult(executorOutputStream.toString(), executorErrorStream.toString(),
                                -1, resultsFileContents);

                        // for concurrency reasons, result must be placed into map before status is
                        // (to avoid situation where result is not yet in map and a thread detects the status is updated)
                        executionResults.put(id, executionResult);
                        executionStatuses.put(id, true);
                    }
                });
            } else {

                // TODO: need to reformulate for standard ExecutionResult object
                char[] fileConsoleDelimeter = new char[80];
                Arrays.fill(fileConsoleDelimeter, '-');

                StringBuilder output = new StringBuilder();

                output.append(this.getClass().getSimpleName()).append(" running in DEBUG mode\n");
                output.append("Executing: "+ commandLine.toString() + "\n");
                output.append("where the file contains: \n\n");
                output.append(fileConsoleDelimeter).append('\n');
                output.append(new String(bytes)).append('\n');
                output.append(fileConsoleDelimeter);

                ExecutionResult executionResult = new ExecutionResult(output.toString(), "",
                        0, "");

                executionResults.put(id, executionResult);
                executionStatuses.put(id, true);

            }

            return id;
        } catch (IOException ioe) {
            // TODO: replace with Executor-specific Exception
            throw new RuntimeException(ioe);
        }
    }

    @Override
    public boolean isFinished(ExecutionId executionId) {
        return executionStatuses.get(executionId);
    }

    @Override
    public ExecutionResult getResult(ExecutionId executionId) {
        return executionResults.get(executionId);
    }

    public void setDebug(boolean debug) {
        this.debug = debug;
    }

}

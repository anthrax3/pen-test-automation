package com.aspectsecurity.astam.tta3.pentest.orchestrator;

/*
    Application Security Threat Attack Modeling (ASTAM)

    Copyright (C) 2017 Applied Visions - http://securedecisions.com

    Written by Aspect Security - http://aspectsecurity.com

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

import com.aspectsecurity.astam.tta3.pentest.command.ToolCommandGenerator;
import com.aspectsecurity.astam.tta3.pentest.common.ExecutionResult;
import com.aspectsecurity.astam.tta3.pentest.common.ToolCommand;
import com.aspectsecurity.astam.tta3.pentest.common.ToolResult;
import com.aspectsecurity.astam.tta3.pentest.common.Tta3Attack;
import com.aspectsecurity.astam.tta3.pentest.execute.CommandExecutor;
import com.aspectsecurity.astam.tta3.pentest.execute.ExecutionId;
import com.aspectsecurity.astam.tta3.pentest.execute.cli.CliExecutor;
import com.aspectsecurity.astam.tta3.pentest.execute.cqf.CqfExecutor;
import com.aspectsecurity.astam.tta3.pentest.tools.spi.ToolWrapper;
import org.apache.commons.cli.*;

import java.util.*;
import java.util.stream.Collectors;

/**
 *
 */
public class Tta3Orchestrator {


    public static void main(String[] args) throws Exception {
        CommandLineParser commandLineParser = new DefaultParser();
        HelpFormatter formatter = new HelpFormatter();
        Options options = new Options();
        options.addOption( Option.builder("h").longOpt("help").desc("print this help").required(false).hasArg(false).build() );
        options.addOption( Option.builder("cli").desc("use CLI executor for tool commands").required(false).hasArg(false).build() );
        options.addOption( Option.builder("cqf").desc("use CQF executor for tool commands").required(false).hasArg(false).build() );
        options.addOption( Option.builder("t").longOpt("target-host").desc("host URL to target").required(false).hasArg(true).build() );
        options.addOption( Option.builder().longOpt("cqf-api").desc("CQF REST API endpoint URL").required(false).hasArg(true).build() );
        options.addOption( Option.builder("a").longOpt("capec-id").desc("attack pattern (CAPEC) to use").required(false).hasArg(true).build() );

        CommandLine line = commandLineParser.parse(options, args);

        if (line.hasOption("h")) {
            if (line.getOptions().length > 1) {
                System.err.println("Incompatible options");
            }
            formatter.printHelp( Tta3Orchestrator.class.getSimpleName(), options );
            return;
        }

//        if (!line.hasOption("capec-id")) {
//            System.err.println("CAPEC ID for attack pattern to use must be provided");
//            formatter.printHelp( Tta3Orchestrator.class.getSimpleName(), options );
//            return;
//        }

//        if (line.hasOption("cqf") && !line.hasOption("cqf-api")) {
//            System.err.println("CQF REST API endpoint URL must be provided when using CQF executor");
//            formatter.printHelp( Tta3Orchestrator.class.getSimpleName(), options );
//            return;
//        }

//        if (line.hasOption("cli") && !line.hasOption("target-host")) {
//            System.err.println("Host URL to target must be provided when using CLI executor");
//            formatter.printHelp( Tta3Orchestrator.class.getSimpleName(), options );
//            return;
//        }

        boolean isCqf = false;//line.hasOption("cqf");
        boolean isCli = true;//line.hasOption("cli");

        String targetUrl = line.getOptionValue("target-host", "http://locahost:8080/");
        String cqfApiUrl = line.getOptionValue("cqf-api", "http://localhost:8080/cqf/api/v1");

        // This stuff that we plan on deriving from a Finding/PotentialAttack but for now we are either deriving from
        // command line arguments are hard coding
        Map<String, String> applicationMetadata = new HashMap<>();

        // This would come from a Finding or a PotentialAttack
        String capecId = line.getOptionValue("capec-id","CAPEC-16");

        // The path/query part of URL would come from a DAST Finding. Alternatively, if a PotentialAttack indicated
        // a use case for a component, could come from interactive prompting for the URL of that use case.
        applicationMetadata.put("sqliURL", targetUrl + "/JSONTags?start=0&count=10&sort=tagname");

        // This would have to come deus ex machina until we have a fully functional pen test analyst workbench
        applicationMetadata.put("loginURL", targetUrl+ "/admin");

        // This probably wouldn't come in at all but hard coding it to save time during demo as it cuts down on
        // unnecessary testing
        applicationMetadata.put("sqliParam", "sort");


        // TODO: we should be deriving these values from target-host config parameter
        applicationMetadata.put("host", "localhost");
        applicationMetadata.put("port", "8080");
        applicationMetadata.put("useTLS", "0");
        //

        // TODO: uripath and sqliURL are similar; these should be generalized as a common attack config parameter
        applicationMetadata.put("uripath", "/c/portal_public/login");

        applicationMetadata.put("username", "bill@dotcms.com");
        applicationMetadata.put("formdata", "my_account_cmd=auth&referer=%2Fc&my_account_r_m=false&password=^PASS^&my_account_login=^USER^&my_account_email_address=");
        applicationMetadata.put("msgsuccess", "Processing login...");
        applicationMetadata.put("dictionaryfile","sample-dictionary-02.txt");

        // The Pen Test Planning module will eventually build out the normalized Tta3Attack object
        Tta3Attack tta3Attack = new Tta3Attack(capecId, applicationMetadata);

        // Begin programmatic stuff
        ToolCommandGenerator commandGenerator = ToolCommandGenerator.getInstance();

        // Show currently supported CAPECS:
        System.out.println("TTA3 Currently Supports:" + commandGenerator.getSupportedCapecs());

        System.out.println();
        System.out.println("User requested attack pattern " + capecId + " against target URL " + targetUrl);

        if (!commandGenerator.getSupportedCapecs().contains(capecId)) {
            System.out.println(capecId + " is not currently supported.");
            return;
        }

        // Get tool for targeted CAPEC"
        Set<ToolWrapper> toolWrappers = commandGenerator.getToolForCapec(capecId);

        System.out.println();
        System.out.println("For " + capecId + ", TTA3 can use the following tools: "
                + toolWrappers.stream().map(t->t.getToolName()).collect(Collectors.toSet()));

        // Choose first available tool
        ToolWrapper chosenTool = toolWrappers.iterator().next();

        // Report what tool was selected
        System.out.println();
        System.out.println("TTA3 automatically selected: " + chosenTool.getToolName());

        // Show parameters needed for tool
        System.out.println();
        System.out.println("According to its plugin manifest, " + chosenTool.getToolName() + " supports the following parameters: ");
        chosenTool.getToolParameters().stream()
                .forEach(p -> { System.out.println("\t"
                        + p.getParamName()
                        + ( p.isRequired() ? " *required*" : "")
                        + " (" + p.getParamType() + "): "
                        + p.getParamDescription() ); } );

        // Lookup parameters in metadata
        System.out.println();
        System.out.println("Populating tool parameters based on application, threat modeling, and finding metadata: ");
        chosenTool.getToolParameters().stream()
                .forEach(p -> {
                    if (applicationMetadata.get(p.getParamName()) != null) {
                        System.out.println("\t" + p.getParamName() + ": " + applicationMetadata.get(p.getParamName()) );

                        // set tool parameter value
                        p.setValue(applicationMetadata.get(p.getParamName()));
                    } } );

        // Generate Command Object
        ToolCommand toolCommand = chosenTool.generateToolCommand(tta3Attack);

        // Display Command Object
        System.out.println();
        System.out.println(chosenTool.getToolName() + " generated the following TTA3 ToolCommand object:");
        System.out.println("\texecutable: " + toolCommand.getToolExecutableName());
        System.out.println("\tverbose: " + toolCommand.isVerbose());
        System.out.println("\tconfig file:" + Base64.getEncoder().encodeToString(toolCommand.getFileContents()));

        if (isCli) {
            // Execute on CLI
            System.out.println();
            System.out.println("Using CLI executor would execute: ");

            // Use debug mode to simulate execution
            CommandExecutor cliExecutor = new CliExecutor(true);
            ExecutionId eid = cliExecutor.execute(tta3Attack, toolCommand);

            while (!cliExecutor.isFinished(eid)) {}

            // In debug mode, execution output is in stdout
            System.out.println(cliExecutor.getResult(eid).getStdOut());

            // Do the actual execution
            System.out.println("Performing actual execution: ");
            cliExecutor = new CliExecutor(false);
            eid = cliExecutor.execute(tta3Attack, toolCommand);

            while (!cliExecutor.isFinished(eid)) { }

            ExecutionResult executionResult = cliExecutor.getResult(eid);

            if (chosenTool.isSuccessfulExit(executionResult)) {
                System.out.println("Status: Completed");
            } else {
                System.out.println("Status: Error");
                System.out.println("Exit Code: " + executionResult.getExitCode());
                System.out.println("StdErr: " + executionResult.getStdError());
            }

            System.out.println("SdtOut: " + executionResult.getStdOut());
            System.out.println("Raw Result: " + executionResult.getResultFileContents());

            System.out.println();

            ToolResult toolResult = chosenTool.parseAttackResult(tta3Attack, executionResult);

            System.out.println("Processed Results: ");
            System.out.println("\tSuccessful Run: " + toolResult.isSuccessfulRun());
            System.out.println("\tVulnerability Found: " + toolResult.isVulnerabilityFound());
            System.out.println("\tNumber of Vulnerabilities: " + toolResult.getQuantityFound());
            System.out.println("\tResults: " + toolResult.getResultsText());


        }

        if (isCqf) {
            // Execute on CQF
            System.out.println();
            System.out.println("Using CQF executor would send the following request to " + cqfApiUrl +" : ");

            // Use debug mode to simulate execution
            CommandExecutor cqfExecutor = new CqfExecutor();

            ExecutionId eid = cqfExecutor.execute(tta3Attack, toolCommand);

            while (!cqfExecutor.isFinished(eid)) {}

            System.out.println(cqfExecutor.getResult(eid).getStdOut());

            // TODO: find a way to short circuit the socket timeout
            //System.exit(0);

            // Do the actual execution
            System.out.println("Performing actual execution: ");
            cqfExecutor = new CqfExecutor(cqfApiUrl);
            eid = cqfExecutor.execute(tta3Attack, toolCommand);

            while (!cqfExecutor.isFinished(eid)) { }

            ExecutionResult executionResult = cqfExecutor.getResult(eid);

            if (chosenTool.isSuccessfulExit(executionResult)) {
                System.out.println("Status: Completed");
            } else {
                System.out.println("Status: Error");
                System.out.println("Exit Code: " + executionResult.getExitCode());
                System.out.println("StdErr: " + executionResult.getStdError());
            }

            System.out.println("SdtOut: " + executionResult.getStdOut());
            System.out.println("Raw Result: " + executionResult.getResultFileContents());

        }
    }
}

package com.aspectsecurity.tta3.pentest.tools.xssmap;

import com.aspectsecurity.astam.tta3.pentest.common.ExecutionResult;
import com.aspectsecurity.astam.tta3.pentest.common.ToolCommand;
import com.aspectsecurity.astam.tta3.pentest.common.ToolResult;
import com.aspectsecurity.astam.tta3.pentest.common.Tta3Attack;
import com.aspectsecurity.astam.tta3.pentest.tools.spi.ToolParameter;
import com.aspectsecurity.astam.tta3.pentest.tools.spi.ToolWrapper;
import com.aspectsecurity.astam.tta3.pentest.tools.spi.common.BooleanToolParameter;
import com.aspectsecurity.astam.tta3.pentest.tools.spi.common.StringToolParameter;
import com.aspectsecurity.astam.tta3.pentest.tools.spi.common.UrlToolParameter;
import com.aspectsecurity.tta3.pentest.tools.xssmap.domain.ExecutionResultObject;
import com.aspectsecurity.tta3.pentest.tools.xssmap.domain.XssResult;
import com.google.common.collect.ImmutableSet;
import com.google.gson.Gson;
import org.apache.commons.lang3.builder.ToStringBuilder;
import java.util.*;

/*
    Application Security Threat Attack Modeling (ASTAM)

    Copyright (C) 2017 Applied Visions - http://securedecisions.com

    Written by Aspect Security - http://aspectsecurity.com

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
 * Wrapper SPI for ESM-7 tool.
 *
 * @author Aspect Security
 */
public class XssMapWrapper implements ToolWrapper {

    private static final Set<String> SUPPORTED_ATTACKS = ImmutableSet.of("CAPEC-243");

    final StringToolParameter xssRequestTypeParameter = new StringToolParameter("xssRequestType",
            // TODO: support internationalization with parameterized message string
            "HTTP request type (GET or POST)",
            false);

    final UrlToolParameter xssUrlParameter = new UrlToolParameter("xssRequestURL",
            // TODO: support internationalization with parameterized message string
            "Request URL string",
            true);

    // TODO: convert this to an http request tool parameter
    final StringToolParameter xssRequestBodyParameter = new StringToolParameter("xssRequestBody",
            // TODO: support internationalization with parameterized message string
            "(Only if request type of POST) Request body string, URL form-encoded",
            false);

    final BooleanToolParameter xssOnlyFlagParameter = new BooleanToolParameter("xssOnly",
            "Indicates if only XSS scanning should be performed",
            false);

    final Set<ToolParameter> toolParameters = ImmutableSet.of(
            xssRequestTypeParameter,
            xssUrlParameter,
            xssRequestBodyParameter,
            xssOnlyFlagParameter
    );

    @Override
    public String getToolName() {
        return "XssMap";
    }

    @Override
    public Set<ToolParameter> getToolParameters() {
        return toolParameters;
    }

    @Override
    public Set<String> getSupportedAttacks() {
        return SUPPORTED_ATTACKS;
    }

    @Override
    public ToolResult parseAttackResult(Tta3Attack attack, ExecutionResult executionResult)
    {
        Gson gson = new Gson();

        ExecutionResultObject executionResults = gson.fromJson(executionResult.getResultFileContents(),
                ExecutionResultObject.class);

        if (executionResults == null) {
            return new ToolResult(false, false, 0, "Error parsing JSON.");
        }

        // Collect the XSS-vulnerable parameters and their contexts

        List<XssMapResults.XssVulnerability> vulns = new ArrayList<>();
        StringBuilder resultsText = new StringBuilder();

        for (XssResult thisResult : executionResults.results.xss_scan) {

            StringBuilder sb = new StringBuilder();

            // Populate HTTP request type
            sb.append("Request type: " + executionResults.request_type + "\n");

            // Populate request URL root
            sb.append("Request URL root: " + executionResults.request_url_root + "\n");

            // TODO Populate vulnerable parameter name
            sb.append("Parameter: " + "\n");

            // TODO Populate attack vector - URL or body?
            sb.append("Attack vector: " + "\n");

            // TODO Populate payload about this attack
            sb.append("Payload: " + "\n");

            // Populate message about this attack
            sb.append("Message: " + thisResult.msg + "\n");

            sb.append("--------------------------------------------------------------------------------\n");

            resultsText.append(sb.toString());

            XssMapResults.XssVulnerability thisVuln = new XssMapResults.XssVulnerability(executionResults.request_type,
                    executionResults.request_url_root, "", "", "", thisResult.msg);

            vulns.add(thisVuln);
        }

        return new XssMapResults(true, !vulns.isEmpty(), vulns.size(),
                resultsText.toString(), vulns);
    }

    @Override
    public ToolCommand generateToolCommand(Tta3Attack attack) {
        if (!getSupportedAttacks().contains(attack.getCapecId())) {
            // TODO: support internationalization with parameterized message string
            throw new UnsupportedOperationException("Attack " + attack.getCapecId() + " is not supported.");
        }

        if (!isValidParameters()) {
            // TODO: support internationalization with parameterized message string
            throw new IllegalArgumentException("Invalid attack configuration.");
        }

        return new ToolCommand("xssmap", generateXssMapConfFile().getBytes(), true);
    }

    private boolean isValidParameters() {
        return toolParameters.parallelStream().allMatch(t -> (
                // if the value is not null, it must be valid
                (t.getValue() != null && t.isValid())
                        // if the value is null, then it must be not required
                      || (t.getValue() == null && !t.isRequired())
        ));
    }

    /*
        Generates a JSON string meant to be used as an input file to XssMap
     */
    private String generateXssMapConfFile() {

        StringBuilder fileContents = new StringBuilder("{\n");

        fileContents.append("\t\"json_version\": 1.00,\n");
        fileContents.append("\t\"request_type\": \"");

        boolean isPOST = false;

        // HTTP request type of the attack - only support GET or POST, default to GET
        if (xssRequestTypeParameter.getValue() != null
                && xssRequestTypeParameter.getValue().toUpperCase().equals("POST")) {
            fileContents.append("POST");
            isPOST = true;
        }
        else {
            fileContents.append("GET");
        }

        fileContents.append("\",\n");
        fileContents.append("\t\"request_url\": \"");

        // URL for attack location (required)
        fileContents.append(xssUrlParameter.getValue());

        fileContents.append("\",\n");

        // HTTP POST parameter string for attack location (only if attack is POST)
        if (true == isPOST && xssRequestBodyParameter.getValue() != null) {
            fileContents.append("\t\"request_body\": \"");
            fileContents.append(xssRequestBodyParameter.getValue());
            fileContents.append("\",\n");
        }

        fileContents.append("\t\"do_reflect\": ");

        // If XSS only flag is true, then put false, otherwise put true
        if (xssOnlyFlagParameter.getValue() != null && Boolean.parseBoolean(xssOnlyFlagParameter.getValue()) == true)
        {
            fileContents.append("false");
        }
        else {
            fileContents.append("true");
        }

        fileContents.append(",\n");
        fileContents.append("\t\"do_xss\": true,\n");
        fileContents.append("\t\"headers\": [],\n");
        fileContents.append("\t\"cookies\": []\n");
        fileContents.append("}");

        return fileContents.toString();
    }

    @Override
    public String toString() {
        return new ToStringBuilder(this).
                append("toolName", getToolName()).
                append("supportedAttacks", getSupportedAttacks()).
                toString();
    }
}
